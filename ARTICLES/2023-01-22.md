# 2023-01-22

こんにちは！

こんにちは

今日はファイル処理に関して基本的な知識を学習する。大部分はすでに知っているかもしれないが、念のため確認する。

## 文字コードについて

日本語でよく使う文字コードは以下の通り。

- SJIS (シフトJIS)
- UTF-8
- UTF-16 (little endian)
- UTF-16 (big endian)

UTF-8やUTF-16ではテキストファイルの先頭にBOM（Byte Order Mark）が付くことがある。BOMは文字コードの種類を表す。
テキストファイルを「BOMつきUTF-8」として保存すると先頭に「EF BB BF」の３バイトが付く。これがUTF-8のBOM。
UTF-16のBOMは、little endianなら「FF FE」、big endianであれば「FE FF」の2バイト。
BOMがあれば文字コードの判定が楽になるという利点があるが、ときどき邪魔になることがある。

UTF-8もUTF-16もUnicode文字列を表すのは同じだが、文字の符号化方式が異なる。
UTF-8は1個以上のchar型で1文字を表すマルチバイト文字列で、Web技術で広く使われている。
Windowsの内部ではUnicode文字列はwchar_t（WCHAR）の列、いわゆるワイド文字列として扱われる。
Windowsではワイド文字列はUTF-16だが（sizeof(wchar_t) == 2）、他のOSだとUTF-32かもしれない（sizeof(wchar_t) == 4）。
UTF-16では、サロゲート以外の1文字はWCHAR 1個で表せる。
サロゲート文字は、UTF-16の符号化の例外で2個のWCHARで1文字を表現する。
これはWCHAR 1個では情報量が足りなかったという悲しいUnicodeの歴史の名残である。
シフトJISは、MS-DOSから続く過去の資産として日本語Windowsで使われている。

Webでは「BOMなしUTF-8」が標準で、UTF-16やシフトJISは嫌われている。

## コードページについて

Windowsではコードページを指定してANSI文字列を扱うことができる。コードページとは文字コードの種類を表す整数だ。
CP_ACPは現在のコードページ、CP_UTF8はUTF-8のコードページ、シフトJISのコードページは932となっている。
現行の日本語WindowsではCP_ACPは932にマップされるが、非日本語圏や将来のシステムでは932ではない可能性がある。

## 文字コードの変換

UTF-16をUTF-16以外の文字コードに変換するには、コードページを指定してWideCharToMultiByte関数を使う。
UTF-16以外の文字コードをUTF-16に変換するには、コードページを指定してMultiByteToWideChar関数を使う。
この二つの関数はヌル終端を保証しないので、バッファオーバーランに注意すること。

C++で文字コードの変換を頻繁に使用する場合は、次のようなヘルパー関数を使うと変換が容易になる。

```cxx
std::wstring WideFromAnsi(UINT codepage, const char* ansi)
{
    // ワイド文字列に変換。
    WCHAR wide[1024];
    MultiByteToWideChar(codepage, 0, ansi, -1, wide, _countof(wide));
    wide[_countof(wide) - 1] = 0; // バッファオーバーランを防ぐ。
    return wide;
}
```

また、ログイン機構など、セキュリティ上重要なプログラムは、不正なUnicode変換をチェックしないといけない。
具体的には、MultiByteToWideChar関数の第二引数でMB_ERR_INVALID_CHARSを使用して戻り値を確認したり、
WideCharToMultiByte関数の引数lpUsedDefaultCharを使用する。

## 実行ファイルについて

Windowsの実行可能ファイル(EXE、DLL、SCRなど)の中身は、PE形式（PE format）という構造に従っている。

`<winnt.h>`では、PE構造に関するIMAGE_DOS_HEADER、IMAGE_FILE_HEADER、IMAGE_NT_HEADERS32/64などの構造体が定義されている。

例えばバイナリエディタで実行ファイルを開くと、ファイル先頭に「MZ」があり、これはIMAGE_DOS_HEADERのe_magicに相当する。

PE形式を扱うツールやライブラリなどを活用すればWindows以外のOSでも実行ファイルを解析できる。

## DLLについて

DLLは、Dynamic Link Libraryの略で、動的に関数を読み込んで使うことができる。

以前見たように、IMEファイルの実体は、拡張子.imeのDLLファイルだった。
またプラグインファイルも拡張子の違うDLLファイルである。DLLの多くは機能の追加に使われる。

独自のDLLを使用する場合は、関数プロトタイプやインターフェイスを決めないといけない。
DLLの関数はC言語互換が望ましい。

CMakeではadd_library(... SHARED ...)でDLLを作成できる。

## スタティックライブラリについて

DLLではないライブラリは、スタティックライブラリと呼ばれる。
関数の実体を直接プログラムに取り込んで使用する。

CMakeではadd_library(... STATIC ...)でスタティックライブラリを作成できる。

## インポートについて

PE形式では、使用する外部の関数の名前（またはordinalと呼ばれる番号）と、その関数のあるDLLの名前をインポートテーブルに格納する。
システムに存在しないDLLや、存在しない関数をインポートテーブルで参照すると、アプリの起動に失敗する。

C++/Win32プログラミングでは、使用する関数プロトタイプを含むヘッダをインクルードして、インポートライブラリをリンクすれば、インポートできる。
例えば、shlwapi.dllを使いたい場合は、`#include <shlwapi.h>` をソースファイルの上の方に書いて、shlwapi.libをリンクする。

CMakeでは target_link_libraries(... PUBLIC ...) でターゲットをライブラリにリンクできる。

## エクスポートについて

PE形式では、外部から使用できる関数群は、エクスポートテーブルに格納される。
エクスポートされている関数は、外部からインポートライブラリを使ってインポートするか、LoadLibrary/GetProcAddress/FreeLibrary関数を使用して参照できる。

Win32プログラミングでは、拡張子.defのDEFファイルのEXPORTS文にエクスポートする関数を記述して、DEFファイルをプロジェクトに追加することでエクスポートできる。

## ターゲットマシンについて

PE形式ではi386やamd64などのターゲットマシンを指定できる。マシンの値が合致しなければアプリが起動しない。

## ウイルスや脅威などについて

ファイルには、脅威が潜んでいることがある。

システムを破壊するウイルスは直接的な脅威だが、架空請求詐欺や脅迫を行うプログラムや、身代金を要求するランサムウェアも脅威である。

脅威は脅威となる処理を直接、実行するか、外部から別の脅威を引き込もうとする。

ウイルスは伝染することがある。実行ファイルはウイルスに感染することがある。
マクロ付きの文書ファイルは、望まない動作をする恐れがある。
データファイルを扱うプログラムが古いライブラリや間違ったライブラリを使用していると、脆弱性の原因となる。
実際に昔、CUR、ANI、EMFなどには深刻な脆弱性があった。

文書や画像などを扱う場合は、Web標準のファイル形式を推奨する。

## ファイルの同一性の確認

ウイルスなどによってファイルが書き換えられる恐れがあるので、ファイルの同一性確認は重要である。

ファイルに対してsha1sum.exeというプログラムを使えば、SHA-1のチェックサムを確認できる。
チェックサムが同一であれば、ファイルの中身もおそらく同じであると推定できる。

```bash
$ sha1sum.exe epx.exe
26aeaf72e93253f61a5f19d6b34358f935c3be74 *epx.exe
```

他には、確実ではないがファイルのバイト数を確認する方法もある。ファイルサイズが異なれば中身も異なることは間違いない。

## アイコン偽装・拡張子偽装・テキスト偽装

外部から来たファイルを確認したいときは、右クリックの「プロパティ」で確認するのが鉄板だ。
人間の認知というものはあてにならない。

EXE/SCRファイルは自由にアイコンが変更できるから、ファイルアイコンの見た目だけで判断するのは危険。
例えばフォルダやテキストファイルのような見た目のEXEファイルは簡単に作れる。

Unicodeは文字種が豊富で、似たような文字がたくさんある。「В」「Ｂ」違いがわかるだろうか。
「В」のコードポイントはU+0412で、「Ｂ」のコードポイントはU+FF22。別の文字である。
確実に確認するには、バイト列やコードポイントを一つ一つ調べないといけない。

拡張子は2重3重に付くことがある。「Not-a-text-file.txt　　　　　　.exe」というファイル名もあり得る。
shlwapi.dllのPathFindExtensionA/W関数を使うと、パスファイル名から拡張子を探し出してくれる。

アラビア語やヘブライ語のテキストでは右から左へ読むことがあり、テキストの向きが異なることがある。
Unicodeには、テキストの向きを切り替える制御文字（RLM/LRM）がある。
拡張子「.scr」が危険だとわかっていてもテキストの方向の変わった「rcs.EXAMPLE.txt」が危険だとは思わないかもしれない。

## ファイルの属性について

ファイルのプロパティを見ると、ファイルやフォルダには属性が付いているのがわかる。
GetFileAttributes関数でファイルの属性をビットフラグとして取得でき、SetFileAttributes関数でファイルの属性を変更できる。

「読み取り専用」属性は、FILE_ATTRIBUTE_READONLYビット。これはフォルダ以外のとき、ファイルの書き込みを禁止する。
「隠しファイル」属性は、FILE_ATTRIBUTE_HIDDENビットで、この属性のあるファイルやフォルダは通常ユーザーには見えない。
ただし、「隠しファイルを表示する」設定にすれば見ることができる。

「システム」属性は、FILE_ATTRIBUTE_SYSTEMビット。システム属性と隠し属性の両方が付いたファイルは、SuperHiddenと呼ばれ、さらに見えにくい。

「ディレクトリ」属性は、FILE_ATTRIBUTE_DIRECTORYビットでフォルダかフォルダではないかを表す。

## ADSとZoneIDについて

ファイルには、通常のファイルの中身以外に「代替データストリーム(ADS)」と呼ばれるバイト列を追加することができる。
システムのブラウザは外部から来たファイルにZoneID（ゾーンID）と呼ばれるADSを追加する。
システムは、ZoneIDが付いていればそれは外部から来たファイルだと判定する。

## ファイルのロック機構と保護

Windowsにはファイルをロックする機構がある。ロックにより、ファイルの読み書き・削除要求を拒否することができる。
CreateFileA/W関数の第三引数、LockFile[Ex]/UnlockFile[Ex]関数などでファイルをロックできる。

実行中のEXEファイルの中身の変更や、実行中のEXEファイルの存在するフォルダの名前変更や削除もできないようになっている。

「C:\Program Files」「C:\Windows」などはシステムによって保護されたフォルダだ。
保護されたフォルダでは、管理者権限のない第三者によるファイルの書き換えを抑止する。
インストーラなどのプログラムは、システムの変更のために管理者権限を要求する。

共有フォルダにおいては、フォルダのアクセス権の設定を使うと、アクセスできるユーザーを制限できる。

## フォルダの作成・削除

CreateDirectory[Ex]A/W関数を使えば、フォルダを作成できる。
RemoveDirectoryA/W関数を使えば空のフォルダを削除できる。
空でないフォルダを削除するには、SHFileOperationA/W関数などを使う。

## ファイルの読み書き

Win32でファイルを読み込んだり、作成したり、書き込んだりするには、CreateFileA/W関数を使う。
ただし、CreateFileは引数が多いので、初心者向けではないかもしれない。
CreateFileA/Wの戻り値、ファイルハンドルがINVALID_HANDLE_VALUEでなければファイルが開かれる。
ファイルハンドルに対してReadFile[Ex]/WriteFile[Ex]関数を使って読み書きできる。
開いたファイルは、最後にCloseHandle関数で閉じないといけない。

```c
// ファイルを開く。
HANDLE hFile = CreateFile(pszFileName, ...);
if (hFile != INVALID_HANDLE_VALUE)
{
    // TODO: ファイルを処理する。
    ...
    // ファイルを閉じる。
    CloseHandle(hFile);
}
```

C言語では、fopen/_wfopen/_tfopen関数を使うと、FILE*型のファイルポインタを返し、簡単にファイルを開いたり作成することができる。
第二引数には読み書きモードとバイナリとして扱うかどうかを文字列で指定する。
そしてfread/fgetsなどで読み込み、fwrite/fprintf/fputsなどで書き込む。
最後にfclose関数でファイルを閉じる。

読み込み：

```c
// ファイルを読み込みモードで開く。
FILE *fin = fopen("test.txt", "r");
if (fin)
{
    // 一行ずつ読み込む。
    char buf[256];
    WCHAR szText[256];
    while (fgets(buf, _countof(buf), fin))
    {
        // UTF-8からワイド文字列に変換する。
        MultiByteToWideChar(CP_UTF8, 0, buf, -1, szText, _countof(szText));
        szText[_countof(szText) - 1] = 0; // バッファオーバーラン対策。

        // TODO: szTextを使う
        ...
    }
    // ファイルを閉じる。
    fclose(fin);
}
```

書き込み：

```c
// ファイルを書き込みモードで開く。
FILE *fout = _wfopen(szFileName, L"w");
if (fout)
{
    // TODO: ファイルを書き込む。
    fprintf(fout, "This is a test.\n");
    fprintf(fout, "OK, ok.\n");
    ...
    // ファイルを閉じる。
    fclose(fout);
}
```

Windowsでfopenの第二引数に"b"を付けなければ改行コードの変換（`"\n" <--> "\r\n"`；`LF <--> CR LF`）が行われる。

## 現在のファイル読み書き位置

ファイルハンドルに対してSetFilePointer[Ex]関数を使えば、現在のファイルの読み書き位置を変更できる。

ファイルポインタに対してfseek関数を使えば、現在のファイルの読み書き位置を変更できる。
ftell関数を使えば、現在のファイルの読み書き位置を取得できる。

## ファイルの存在確認

GetFileAttributes関数や、shlwapi.dllのPathFileExistsA/W関数でファイルの存在を確認できる。

shlwapi.dllのPathIsDirectoryA/W関数でフォルダの存在を確認できる。

## ファイルのコピー・削除・名前変更・移動

ファイルのコピーには、CopyFileA/W関数、SHFileOperationA/W関数を使う。

ファイルの削除には、DeleteFileA/W関数、remove/_wremove/_tremove関数、SHFileOperationA/W関数を使う。

ファイルの改名・移動には、MoveFile[Ex]A/W関数、SHFileOperationA/Wを使う。

## ユーザーによるファイルの選択

ユーザーに開きたいファイルを選択させたい場合は、GetOpenFileNameA/W関数を使う。

ユーザーに保存先のファイルを入力させたい場合は、GetSaveFileNameA/W関数を使う。

ユーザーにフォルダを選択させたいときは、SHBrowseForFolderA/W関数を使う。

## パスの区切り

Windowsでは、半角の円記号（バックスラッシュ）はパスの区切りとして使われる。
スラッシュ（/）もパスの区切りかもしれないが、場合によっては使えないことがある。

パスの区切りを使えば、ディレクトリの中のファイルやディレクトリを指定できる。

## ファイル名に使えない文字

- \ （円記号・バックスラッシュ）
- / （スラッシュ）
- : （コロン）
- * （アスタリスク）
- ? （クエスチョンマーク）
- " （二重引用符）
- `< >`（不等号）
- |（縦棒）

この他に、タブ文字'\t'や改行'\n'、ヌル終端文字'\0'なども使えない。

*と?は、ワイルドカードというパターンマッチ表現で、複数のファイルをいっぺんに指定するのに使われる。

不等号 `< >` は、標準入出力を切り替えるMS-DOS互換のリダイレクションに使われる。
縦棒 | は、MS-DOS互換のパイプ処理に使われる。

二重引用符 " は、空白を含む文字列を扱うのに使われる。
コロン : はドライブ文字を指定するのに使われる。

## ワイルドカードについて

ワイルドカードでは*は0文字以上の文字列にマッチし、?は1文字にマッチする。
MS-DOSではワイルドカードは「dir *.txt」のように使われていた（これはテキストファイルを列挙するコマンド）。

Win32では、FindFirstFile/FindNextFile/FindClose関数を使えば、ワイルドカードにマッチするファイルを探すことができる。

## ファイル名に使わない方がいい文字

& ( ) [ ] { } ^ = ; ! ' + , ` ~

これらの文字は、コマンドプロンプトやバッチファイルで二重引用符で囲まないと特殊な解釈をする。

## URLについて

ホームページやウェブページの場所を表す文字列はURLと呼ばれる。
「http:// 」や 「https:// 」で始まる文字列はおそらくURLである。
RFC 3986は、URLの解釈方法を定めている。
URLでそのまま使用できない文字は、パーセント記号'%'を使ってURLエンコードされる。
URLでは英字の大文字は使用しない方がいい。

## ファイルを開く、実行する

EXEを実行するには、ShellExecute[Ex]A/W関数、CreateProcessA/W関数などを使う。
EXEを指定するにはEXEファイルの絶対パスを指定するか、相対パスを指定する。
PATH環境変数やApp Pathsレジストリキーを使えば、パスの記述を減らすことができる。

URLや文書ファイルを開く場合もShellExecute[Ex]A/W関数が使える。

## 一時ファイル

一時ファイルを作成する場合は、GetTempPathA/W関数かTEMP環境変数の値を使うことが推奨される。

## 環境変数

GetEnvironmentVariableA/W関数を使えば環境変数の値を取得できる。

ExpandEnvironmentStringsA/W関数を使えば、環境変数文字列を展開できる。

## 資格情報

「ITパスポート」「基本情報」「英検2級」が狙い目。

今日はここまで。

ありがとうございました

---

[戻る](2023-01-08.md) | [次へ](2023-01-29.md)
